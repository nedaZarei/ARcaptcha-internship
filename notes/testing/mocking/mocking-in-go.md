# mocking in go testing

---

## what is mocking?

mocking is the practice of replacing real dependencies in your code with fake ones during testing. this helps isolate the unit of code being tested and control the behavior of its dependencies.

mocks can:
- simulate external services (e.g., databases, apis)
- help test edge cases
- improve test speed and reliability
- ensure units are tested in isolation

---

## why mocking is important in go

go emphasizes simplicity, and its interfaces make mocking straightforward. because interfaces in go are satisfied implicitly, you can define small interfaces and easily substitute them in tests.

---

## creating a mock in go

### step 1: define an interface

```go
type storage interface {
    save(data string) error
}
```

### step 2: implement a mock version

```go
type mockStorage struct {
    savedData string
    err       error
}

func (m *mockStorage) save(data string) error {
    m.savedData = data
    return m.err
}
```

### step 3: use the mock in your test

```go
func TestSaveData(t *testing.T) {
    mock := &mockStorage{}
    service := myService{store: mock}

    err := service.process("test")

    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if mock.savedData != "test" {
        t.Errorf("expected data to be 'test', got '%s'", mock.savedData)
    }
}
```

---

## mocking with testify

the `testify/mock` package simplifies mock creation.

### example

```go
type mockStorage struct {
    mock.Mock
}

func (m *mockStorage) save(data string) error {
    args := m.Called(data)
    return args.Error(0)
}

func TestSaveData(t *testing.T) {
    m := new(mockStorage)
    m.On("save", "test").Return(nil)

    s := myService{store: m}
    err := s.process("test")

    m.AssertExpectations(t)
}
```

---

## mocking http clients

### using `httptest.Server`

```go
func TestAPIClient(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"status": "ok"}`))
    }))
    defer server.Close()

    client := apiClient{baseURL: server.URL}
    resp := client.call()

    if resp.Status != "ok" {
        t.Errorf("expected 'ok', got '%s'", resp.Status)
    }
}
```

---

## integration vs unit tests with mocks

- **unit tests**: focus on isolated components, mock dependencies.
- **integration tests**: test multiple components together, but you can still mock external systems (like databases or apis) to avoid side effects or network issues.

example: in integration tests, you might use an in-memory database or a fake external service.

---

## tips for effective mocking

- define minimal interfaces to mock only what's necessary.
- avoid over-mocking; it's better to test behavior than implementation.
- use mocking frameworks like `testify` when things get verbose.
- combine mocking with table-driven tests for clean, reusable patterns.

---

## mocking database interactions

you can mock database interactions by using interfaces for your data access layer.

### example using a repository interface

```go
type userRepository interface {
    findUserByID(id string) (*User, error)
}

type mockUserRepo struct {
    mock.Mock
}

func (m *mockUserRepo) findUserByID(id string) (*User, error) {
    args := m.Called(id)
    return args.Get(0).(*User), args.Error(1)
}

func TestGetUser(t *testing.T) {
    repo := new(mockUserRepo)
    user := &User{ID: "123", Name: "alice"}
    repo.On("findUserByID", "123").Return(user, nil)

    service := userService{repo: repo}
    result, err := service.getUser("123")

    require.NoError(t, err)
    assert.Equal(t, "alice", result.Name)

    repo.AssertExpectations(t)
}
```

---

## mocking external api calls

when your service calls an external api, wrap the http client call inside an interface so you can mock it.

### example

```go
type weatherClient interface {
    getTemperature(city string) (float64, error)
}

type mockWeatherClient struct {
    mock.Mock
}

func (m *mockWeatherClient) getTemperature(city string) (float64, error) {
    args := m.Called(city)
    return args.Get(0).(float64), args.Error(1)
}

func TestWeatherService(t *testing.T) {
    client := new(mockWeatherClient)
    client.On("getTemperature", "london").Return(21.0, nil)

    svc := weatherService{client: client}
    temp, _ := svc.fetch("london")

    assert.Equal(t, 21.0, temp)
}
```

---

## real-world directory structure for mocks

```
/your-project
│
├── /internal
│   ├── /service         # your business logic
│   │   └── user.go
│   └── /repository      # interfaces and real implementations
│       └── user_repo.go
│
├── /mocks               # autogenerated or hand-written mocks
│   └── user_repo_mock.go
│
├── /test                # integration or helper utilities
│   └── test_utils.go
│
└── /cmd                 # entrypoints
    └── main.go
```

- keep interfaces in `internal/repository`
- place hand-written or generated mocks in a dedicated `/mocks` folder
- use `mockery` or `counterfeiter` to generate mocks automatically

---

## references

- david christianto: [software testing - mock testing](https://medium.com/@david.christianto05/software-testing-mock-testing-76f572b58936)
- chris james: [learn go with tests - mocking](https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/mocking)
- nina pakshina: [mocking integration tests in go](https://medium.com/@ninucium/mocking-integration-tests-in-go-nina-pakshina-d01eefe5251d)
- testify: [https://github.com/stretchr/testify](https://github.com/stretchr/testify)
- go standard library: [`httptest`](https://pkg.go.dev/net/http/httptest)
